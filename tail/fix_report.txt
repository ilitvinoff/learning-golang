1.)
```$ ./tail  -p go.txt
 ING google.com (142.250.186.78): 56 data bytes```
почему-то глотнуло букву P
fixed;

2.)
если я тейлю и пингую гугл, а потом стопаю пингер, захожу редактором в файл и сношу его контент полностью,
и пишу в файл 123 и сохраняю - тейлалка почему-то это не подхватывает, хотя у файла явно сильно поменялось количество строк

>>Если можно задайте рамки изменения размера файла, на которое нужно реагировать.
NOT FIXED;

3.)
```hpcloudTailCfg := &myhpcloudTailCfg{getConfigFromFlags(), sync.WaitGroup{}}```
типичная проблема, когда конфиг превращается в неконфиг.

t.wg.Add(1)
эта строчка указывает на проблему с именованием.

>>Проведено переименование в соответствии с функциональным смыслом.
fixed

4.)
watchPollDelay явно надо настраивать, т.к. кому-то ок раз в секунду проверять, а кому-то нужно намного чаще

>>Добавлен флаг '-delay', значение задается в мс, по умолчанию - 100мс.
fixed

5.)
```START:```
пожалуйста, только без меток и гото. это плохо.
>>Замена меток на бесконечный цикл с условием выхода через break.
fixed

6.)
```type myTailConfig struct {
...
type config struct {
...
    tailConfig        *tail.Config```
явно конфиги надо называть лучше чем config
кстати, я вот не помню, в голанге локальные типы-структы - с маленькой буквы? сложно привыкнуть ух)

>>Переименовано:
>>myTailConfig -> TailState
>>tailConfig -> hpcloudTailCfg
>>
>>Не уверен с выбором имен, но лучше ничиго не придумал.
>>"в голанге локальные типы-структы - с маленькой буквы?" - да, можно :)

7.)
в TailF явно появляются ошибки, но они часто логируются и проглатываются.
не совсем понятно какие ошибки могут быть, и если уж вылетела ошибка - то почему она проглатывается.

Не нашел ошибку, можно подробнее пожалуйста.

При возникновение error в TailF, проиходит вызов: logFatalIfError(err).
```func logFatalIfError(err error) {
	if err != nil {
		log.Fatal(err)
	}
}```
NOT FIXED;

8.)
По поводу
```TailF(...){
...
tail.Cleanup()
}```

>>Я добавил вызов Cleanup, именно с целью очистки всех "висяко", но видимо я не правильно понимаю,
>>как происходит остановка программы (Ctrl+C эквивалентен крашу?).
>>Буду признателен, если просветите.
NOT FIXED;

9.)
код setCursorPos выглядит как порядочно неэффективный. шкутыльгать по одному байту...
        ```file.Seek(cursor, io.SeekEnd)

        char := make([]byte, 1)
        file.Read(char)
```
тут нет проверки на ошибки (вы не проверяете что возвращает Seek и Read), поэтому если что-то случиться, то программа может выдать всякий неадекват.

>>Ошибки зафаталил. Читаю по 1023 байта за раз.
fixed.

10.)
"... не совсем понятно зачем тут вообще вейтгруппа, т.к. TailF никогда не возвращается, и мы вечно ждем вейтгруппу"

>>Если не использовать вэйтгрупп, то по выполнению кода main.go - программа завершится, без какогго либо вывода на экран.

```func setCursorPos(c *config, filepath string) {```
название функции вообще не отражает суть, без комментариев и норм именований тяжело разобраться.

>>Добавил не большой коммент.

11.)
```case <-w.Event:
            err := t.Stop()
```
есть ли вариант что оно не успеет пару строк дотейлить? вот не знаю.
>> Я уж и помимо :)

12.)
кстати eventsHandler плохое имя для метода, см. код стайл.

>>Мы же тут отлавливаем ивенты(хэндлим вроде:), приведите пример плз.

