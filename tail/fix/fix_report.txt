1.)
```$ ./tail  -p go.txt
 ING google.com (142.250.186.78): 56 data bytes```
почему-то глотнуло букву P
fixed;

2.)
если я тейлю и пингую гугл, а потом стопаю пингер, захожу редактором в файл и сношу его контент полностью,
и пишу в файл 123 и сохраняю - тейлалка почему-то это не подхватывает, хотя у файла явно сильно поменялось количество строк

Проведенная работа:
В watch.go добавлена функция fileSizeController(...), вызываеться она в eventsHandler, при каждой новой записи в файл.
Она сравнивает текущий размер файла с предидущим размером, если текущий меньше, то остановка stopWatcher(...). В режиме
дебагинга видно, что после очистки содержимого файла и его сохранения происходит вызов
```func stopWatcher(t *tail.Tail, c *config, w *watcher.Watcher) {
	t.Cleanup()
	err := t.Stop()
	logFatalIfError(err)
	//To start read from the beggining of the file - set cursor position to start.
	c.hpcloudTailCfg.Location = &tail.SeekInfo{Offset: 0, Whence: 0}
	w.Close()
}```
и создается новые объекты тэйл и вотчер. Если начать дописывать в файл посредством
```ping google.com >> /foo/bar/f.log```
то прога реагирует корректно, если же дописать новую строку в блокноте и сохранить файл,
то прога подвисает и реагирует только на удаление/перемещение файла...
я много передумал, почему так, думал на то, что рутины между собой не синхронезированы,
либо же остановка объекта тэйл происходит не по фен шую. В силу недостатка опыта и знаний
не могу сообразить. Гуглить пробовал.

В initWatcher(...) убрал w.SetMaxEvents(1), будут обрабатываться все события. Не уверен в правильности решения.

3.)
```hpcloudTailCfg := &myhpcloudTailCfg{getConfigFromFlags(), sync.WaitGroup{}}```
типичная проблема, когда конфиг превращается в неконфиг.

t.wg.Add(1)
эта строчка указывает на проблему с именованием.

>>Проведено переименование в соответствии с функциональным смыслом.
fixed

4.)
watchPollDelay явно надо настраивать, т.к. кому-то ок раз в секунду проверять, а кому-то нужно намного чаще

>>Добавлен флаг '-delay', значение задается в мс, по умолчанию - 100мс.
fixed

5.)
```START:```
пожалуйста, только без меток и гото. это плохо.
>>Замена меток на бесконечный цикл с условием выхода через break.
fixed

6.)
```type myTailConfig struct {
...
type config struct {
...
    tailConfig        *tail.Config```
явно конфиги надо называть лучше чем config
кстати, я вот не помню, в голанге локальные типы-структы - с маленькой буквы? сложно привыкнуть ух)

>>Переименовано:
>>myTailConfig -> TailState
>>tailConfig -> hpcloudTailCfg
>>
>>Не уверен с выбором имен, но лучше ничиго не придумал.
>>"в голанге локальные типы-структы - с маленькой буквы?" - да, можно :)

7.)
в TailF явно появляются ошибки, но они часто логируются и проглатываются.
не совсем понятно какие ошибки могут быть, и если уж вылетела ошибка - то почему она проглатывается.

Не нашел ошибку, можно подробнее пожалуйста.

При возникновение error в TailF, проиходит вызов: logFatalIfError(err).
```func logFatalIfError(err error) {
	if err != nil {
		log.Fatal(err)
	}
}```
NOT FIXED;

8.)
По поводу
```TailF(...){
...
tail.Cleanup()
}```

>>Я добавил вызов Cleanup, именно с целью очистки всех "висяко", но видимо я не правильно понимаю,
>>как происходит остановка программы (Ctrl+C эквивалентен крашу?).
>>Буду признателен, если просветите.
NOT FIXED;

9.)
код setCursorPos выглядит как порядочно неэффективный. шкутыльгать по одному байту...
        ```file.Seek(cursor, io.SeekEnd)

        char := make([]byte, 1)
        file.Read(char)
```
тут нет проверки на ошибки (вы не проверяете что возвращает Seek и Read), поэтому если что-то случиться, то программа может выдать всякий неадекват.

>>Ошибки зафаталил. Читаю по 1023 байта за раз.
fixed.

10.)
"... не совсем понятно зачем тут вообще вейтгруппа, т.к. TailF никогда не возвращается, и мы вечно ждем вейтгруппу"

>>Если не использовать вэйтгрупп, то по выполнению кода main.go - программа завершится, без какогго либо вывода на экран.

```func setCursorPos(c *config, filepath string) {```
название функции вообще не отражает суть, без комментариев и норм именований тяжело разобраться.

>>Добавил не большой коммент.

11.)
```case <-w.Event:
            err := t.Stop()
```
есть ли вариант что оно не успеет пару строк дотейлить? вот не знаю.
>> Я уж и помимо :)

12.)
кстати eventsHandler плохое имя для метода, см. код стайл.

>>Мы же тут отлавливаем ивенты(хэндлим вроде:), приведите пример плз.

13.)
вот бы этому приложению какой-то дебаг режим, чтобы оно там евенты логировало и т.д.
как можно тестировать нормально если часть вещей просто невидна?

>>пока, что добавил только логгирование ивентов и подключается логгирование "github.com/hpcloud/tail"
